/*****************************************************************************
TU-BaselineMayfly.ino
Based on: logging_to_MMW.ino, Written By  Sara Damiano (sdamiano@stroudcenter.org)
Modified by: Matt Barney (mbarney@tu.org)
Development Environment: PlatformIO
Hardware Platform: EnviroDIY Mayfly Arduino Datalogger
Software License: BSD-3.
  Copyright (c) 2017, Stroud Water Research Center (SWRC)
  and the EnviroDIY Development Team

This example sketch is written for ModularSensors library version 0.23.16

This shows most of the standard functions of the library at once.

DISCLAIMER:
THIS CODE IS PROVIDED "AS IS" - NO WARRANTY IS GIVEN.
*****************************************************************************/

// For code editing purposes, this is a regexp that can be used to search for UUIDs:
//   ([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}

// ==========================================================================
//    Defines for the Arduino IDE
//    In PlatformIO, set these build flags in your platformio.ini
// ==========================================================================
#ifndef TINY_GSM_RX_BUFFER
#define TINY_GSM_RX_BUFFER 64
#endif
#ifndef TINY_GSM_YIELD_MS
#define TINY_GSM_YIELD_MS 2
#endif
#ifndef MQTT_MAX_PACKET_SIZE
#define MQTT_MAX_PACKET_SIZE 240
#endif

// ==========================================================================
//    Include the base required libraries
// ==========================================================================
#include <Arduino.h>  // The base Arduino library
#include <EnableInterrupt.h>  // for external and pin change interrupts
#include <LoggerBase.h>  // The modular sensors library


// ==========================================================================
//    Data Logger Settings
// ==========================================================================
// The library version this example was written for
const char *libraryVersion = "0.23.16";
// The name of this file
const char *sketchName = "ManisteeHO.ino";
// Logger ID, also becomes the prefix for the name of the data file on SD card
const char *LoggerID = "ManisteeHO";
// How frequently (in minutes) to log data
const uint8_t loggingInterval = 15;
// Your logger's timezone.
const int8_t timeZone = -5;  // -5 is Eastern Standard Time
// NOTE:  Daylight savings time will not be applied!  Please use standard time!


// ==========================================================================
//    Primary Arduino-Based Board and Processor
// ==========================================================================
#include <sensors/ProcessorStats.h>

const long serialBaud = 115200;   // Baud rate for the primary serial port for debugging
const int8_t greenLED = 8;        // MCU pin for the green LED (-1 if not applicable)
const int8_t redLED = 9;          // MCU pin for the red LED (-1 if not applicable)
const int8_t buttonPin = 21;      // MCU pin for a button to use to enter debugging mode  (-1 if not applicable)
const int8_t wakePin = A7;        // MCU interrupt/alarm pin to wake from sleep
// Set the wake pin to -1 if you do not want the main processor to sleep.
// In a SAMD system where you are using the built-in rtc, set wakePin to 1
const int8_t sdCardPwrPin = -1;     // MCU SD card power pin (-1 if not applicable)
const int8_t sdCardSSPin = 12;      // MCU SD card chip select/slave select pin (must be given!)
const int8_t sensorPowerPin = 22;  // MCU pin controlling main sensor power (-1 if not applicable)

// Create the main processor chip "sensor" - for general metadata
const char *mcuBoardVersion = "v0.5b";
ProcessorStats mcuBoard(mcuBoardVersion);


// ==========================================================================
//    Wifi/Cellular Modem Settings
// ==========================================================================

// Create a reference to the serial port for the modem
// Extra hardware and software serial ports are created in the "Settings for Additional Serial Ports" section
HardwareSerial &modemSerial = Serial1;  // Use hardware serial if possible
// AltSoftSerial &modemSerial = altSoftSerial;  // For software serial if needed
// NeoSWSerial &modemSerial = neoSSerial1;  // For software serial if needed

// Modem Pins - Describe the physical pin connection of your modem to your board
const int8_t modemVccPin = -2;      // MCU pin controlling modem power (-1 if not applicable)
const int8_t modemStatusPin = 19;   // MCU pin used to read modem status (-1 if not applicable)
const int8_t modemResetPin = 20;    // MCU pin connected to modem reset pin (-1 if unconnected)
const int8_t modemSleepRqPin = 23;  // MCU pin used for modem sleep/wake request (-1 if not applicable)
const int8_t modemLEDPin = redLED;  // MCU pin connected an LED to show modem status (-1 if unconnected)

// Network connection information
const char *apn = "hologram";  // The APN for the gprs connection

// For any Digi Cellular XBee's
// NOTE:  The u-blox based Digi XBee's (3G global and LTE-M global) can be used
// in either bypass or transparent mode, each with pros and cons
// The Telit based Digi XBees (LTE Cat1) can only use this mode.

// Transparent mode +++++++++++++++++++++++++
#include <modems/DigiXBeeCellularTransparent.h>
const long modemBaud = 9600;  // All XBee's use 9600 by default
const bool useCTSforStatus = false;   // Flag to use the XBee CTS pin for status
// NOTE:  If possible, use the STATUS/SLEEP_not (XBee pin 13) for status, but
// the CTS pin can also be used if necessary
DigiXBeeCellularTransparent modemXBCT(&modemSerial,
                                      modemVccPin, modemStatusPin, useCTSforStatus,
                                      modemResetPin, modemSleepRqPin,
                                      apn);
// Create an extra reference to the modem by a generic name (not necessary)
DigiXBeeCellularTransparent modem = modemXBCT;
// End-block Transparent Mode -------------------------

// Bypass mode +++++++++++++++++++++++++
// #include <modems/DigiXBeeLTEBypass.h>
// const long modemBaud = 9600;  // All XBee's use 9600 by default
// const bool useCTSforStatus = false;   // Flag to use the XBee CTS pin for status
// DigiXBeeLTEBypass modemXBLTEB(&modemSerial,
//                               modemVccPin, modemStatusPin, useCTSforStatus,
//                               modemResetPin, modemSleepRqPin,
//                               apn);
// // Create an extra reference to the modem by a generic name (not necessary)
// DigiXBeeLTEBypass modem = modemXBLTEB;
// End-block Bypass Mode -------------------------


// ==========================================================================
//    Campbell OBS 3 / OBS 3+ Analog Turbidity Sensor
// ==========================================================================
#include <sensors/CampbellOBS3.h>

const int8_t OBS3Power = sensorPowerPin;  // Pin to switch power on and off (-1 if unconnected)
const uint8_t OBS3NumberReadings = 10;
const uint8_t ADSi2c_addr = 0x48;  // The I2C address of the ADS1115 ADC

// ==========================================================================
//    Decagon CTD Conductivity, Temperature, and Depth Sensor
// ==========================================================================
#include <sensors/DecagonCTD.h>

const char *CTDSDI12address = "1";  // The SDI-12 Address of the CTD
const uint8_t CTDNumberReadings = 6;  // The number of readings to average
const int8_t SDI12Power = sensorPowerPin;  // Pin to switch power on and off (-1 if unconnected)
const int8_t SDI12Data = 7;  // The SDI12 data pin

// Create a Decagon CTD sensor object
DecagonCTD ctd(*CTDSDI12address, SDI12Power, SDI12Data, CTDNumberReadings);

// ==========================================================================
//    Maxim DS3231 RTC (Real Time Clock)
// ==========================================================================
#include <sensors/MaximDS3231.h>

// Create a DS3231 sensor object
MaximDS3231 ds3231(1);

// ==========================================================================
// Creating Variable objects for those values for which we're reporting in converted units, via calculated variables
// ==========================================================================

// Create a temperature variable pointer for the Decagon CTD
Variable *CTDTemp = new DecagonCTD_Temp(&ctd, "55bd7a42-34ce-4ebe-aba1-4b4e79993aa8");

// Create a depth variable pointer for the Decagon CTD
Variable *CTDDepth = new DecagonCTD_Depth(&ctd);

// Create a temperature variable pointer for the DS3231
Variable *ds3231Temp = new MaximDS3231_Temp(&ds3231);

// ==========================================================================
// Units conversion functions
// ==========================================================================

float convertDegCtoF(float tempInput)
{ // Simple deg C to deg F conversion
    return tempInput * 1.8 + 32;
}

float convertMmtoIn(float mmInput)
{ // Simple millimeters to inches conversion
    return mmInput / 25.4;
}

// ==========================================================================
// Calculation functions for calculated variables
// ==========================================================================

float getCTDTempinF(void)
{ // Convert temp for the CTD
    return convertDegCtoF(CTDTemp->getValue());
}

float getCTDDepthInIn(void)
{ // Convert depth for the CTD
    // Pass true to getValue() for the Variables for which we're only sending a calculated version
    // of the sensor reading; this forces the sensor to take a reading when getValue is called.
    return convertMmtoIn(CTDDepth->getValue(true));
}

float getDS3231TempinF(void)
{ // Convert temp for the DS3231
    // Pass true to getValue() for the Variables for which we're only sending a calculated version
    // of the sensor reading; this forces the sensor to take a reading when getValue is called.
    return convertDegCtoF(ds3231Temp->getValue(true));
}

// ==========================================================================
// Constructing calculated variables. 
//  (Based on baro_rho_correction.ino and VariableBase.h from enviroDIY.)
// ==========================================================================

// Create the calculated water temperature Variable object and return a pointer to it
Variable *calcCTDTempF = new Variable(
    getCTDTempinF,              // function that does the calculation
    1,                          // resolution
    "temperatureSensor",        // var name. This must be a value from http://vocabulary.odm2.org/variablename/
    "degreeFahrenheit",         // var unit. This must be a value from This must be a value from http://vocabulary.odm2.org/units/
    "TempInF",                  // var code
    "8f9559cf-de79-46dd-8cd5-d756dfe33a76");

// Create the calculated depth Variable object and return a pointer to it
Variable *calcCTDDepthIn = new Variable(
    getCTDDepthInIn,            // function that does the calculation
    1,                          // resolution
    "CTDdepth",                 // var name. This must be a value from http://vocabulary.odm2.org/variablename/
    "Inch",                     // var unit. This must be a value from This must be a value from http://vocabulary.odm2.org/units/
    "waterDepth",               // var code
    "30dcc5ba-4b0e-4b9a-afbe-35440ed52a80");

// Create the calculated Mayfly temperature Variable object and return a pointer to it
Variable *calcDS3231TempF = new Variable(
    getDS3231TempinF,           // function that does the calculation
    1,                          // resolution
    "temperatureDatalogger",    // var name. This must be a value from http://vocabulary.odm2.org/variablename/
    "degreeFahrenheit",         // var unit. This must be a value from http://vocabulary.odm2.org/units/
    "TempInF",                  // var code
    "8f534a71-9629-4d21-bf2e-6489e7062f77");

// ==========================================================================
//    Creating the Variable Array[s] and Filling with Variable Objects
// ==========================================================================

Variable *variableList[] = {
    calcCTDTempF,
    calcCTDDepthIn,
    new DecagonCTD_Cond(&ctd, "f8ed52da-9246-4fa4-8aec-b6f0a40cd3da"),
    CTDTemp,
    new ProcessorStats_Battery(&mcuBoard, "8bafe864-fa8a-4e2b-8e1e-4337356eaf70"),
    calcDS3231TempF,
    new Modem_RSSI(&modem, "cfc4c931-e318-4a1e-b8b2-2366e4be51be"),
    new Modem_SignalPercent(&modem, "2d10c6c5-c09d-4e21-837e-e704e009ce74")
};

// Count up the number of pointers in the array
int variableCount = sizeof(variableList) / sizeof(variableList[0]);

// Create the VariableArray object
VariableArray varArray(variableCount, variableList);


// ==========================================================================
//     The Logger Object[s]
// ==========================================================================

// Create a new logger instance
Logger dataLogger(LoggerID, loggingInterval, &varArray);


// ==========================================================================
//    A Publisher to Monitor My Watershed / EnviroDIY Data Sharing Portal
// ==========================================================================
// Device registration and sampling feature information can be obtained after
// registration at https://monitormywatershed.org or https://data.envirodiy.org
const char *registrationToken = "a48e5421-eb29-42a4-b648-acbaf2737c7c"; // Device registration token
const char *samplingFeature = "44f1519d-e3c6-4686-ad7b-74691ca05b7e";     // Sampling feature UUID

// Create a data publisher for the EnviroDIY/WikiWatershed POST endpoint
#include <publishers/EnviroDIYPublisher.h>
EnviroDIYPublisher EnviroDIYPOST(dataLogger, &modem.gsmClient, registrationToken, samplingFeature);


// ==========================================================================
//    Working Functions
// ==========================================================================

// Flashes the LED's on the primary board
void greenredflash(uint8_t numFlash = 4, uint8_t rate = 75)
{
    for (uint8_t i = 0; i < numFlash; i++) {
        digitalWrite(greenLED, HIGH);
        digitalWrite(redLED, LOW);
        delay(rate);
        digitalWrite(greenLED, LOW);
        digitalWrite(redLED, HIGH);
        delay(rate);
    }
    digitalWrite(redLED, LOW);
}


// Read's the battery voltage
// NOTE: This will actually return the battery level from the previous update!
float getBatteryVoltage()
{
    if (mcuBoard.sensorValues[0] == -9999) mcuBoard.update();
    return mcuBoard.sensorValues[0];
}


// ==========================================================================
// Main setup function
// ==========================================================================
void setup()
{
    // Wait for USB connection to be established by PC
    // NOTE:  Only use this when debugging - if not connected to a PC, this
    // could prevent the script from starting
    #if defined SERIAL_PORT_USBVIRTUAL
      while (!SERIAL_PORT_USBVIRTUAL && (millis() < 10000)){}
    #endif

    // Start the primary serial connection
    Serial.begin(serialBaud);

    // Print a start-up note to the first serial port
    Serial.print(F("Now running "));
    Serial.print(sketchName);
    Serial.print(F(" on Logger "));
    Serial.println(LoggerID);
    Serial.println();

    Serial.print(F("Using ModularSensors Library version "));
    Serial.println(MODULAR_SENSORS_VERSION);

    if (String(MODULAR_SENSORS_VERSION) !=  String(libraryVersion))
        Serial.println(F(
            "WARNING: THIS EXAMPLE WAS WRITTEN FOR A DIFFERENT VERSION OF MODULAR SENSORS!!"));

    // Allow interrupts for software serial
    #if defined SoftwareSerial_ExtInts_h
        enableInterrupt(softSerialRx, SoftwareSerial_ExtInts::handle_interrupt, CHANGE);
    #endif
    #if defined NeoSWSerial_h
        enableInterrupt(neoSSerial1Rx, neoSSerial1ISR, CHANGE);
    #endif

    // Start the serial connection with the modem
    modemSerial.begin(modemBaud);


    // Set up pins for the LED's
    pinMode(greenLED, OUTPUT);
    digitalWrite(greenLED, LOW);
    pinMode(redLED, OUTPUT);
    digitalWrite(redLED, LOW);
    // Blink the LEDs to show the board is on and starting up
    greenredflash();

    // Set the timezones for the logger/data and the RTC
    // Logging in the given time zone
    Logger::setLoggerTimeZone(timeZone);
    // It is STRONGLY RECOMMENDED that you set the RTC to be in UTC (UTC+0)
    Logger::setRTCTimeZone(0);

    // Attach the modem and information pins to the logger
    dataLogger.attachModem(modem);
    modem.setModemLED(modemLEDPin);
    dataLogger.setLoggerPins(wakePin, sdCardSSPin, sdCardPwrPin, buttonPin, greenLED);

    // Begin the logger
    dataLogger.begin();

    // Note:  Please change these battery voltages to match your battery
    // Check that the battery is OK before powering the modem
    if (getBatteryVoltage() > 3.55 || !dataLogger.isRTCSane())
    {
        modem.modemPowerUp();
        modem.wake();
        modem.setup();

        // Synchronize the RTC with NIST
        Serial.println(F("Attempting to connect to the internet and synchronize RTC with NIST"));
        if (modem.connectInternet(120000L))
        {
            dataLogger.setRTClock(modem.getNISTTime());
        }
        else
        {
            Serial.println(F("Could not connect to internet for clock sync."));
        }
    }

    // Set up the sensors, except at lowest battery level
    if (getBatteryVoltage() > 3.4)
    {
        Serial.println(F("Setting up sensors..."));
        varArray.setupSensors();
    }

    // Power down the modem
    modem.disconnectInternet();
    modem.modemSleepPowerDown();

    // Create the log file, adding the default header to it
    // Do this last so we have the best chance of getting the time correct and
    // all sensor names correct
    // Writing to the SD card can be power intensive, so if we're skipping
    // the sensor setup we'll skip this too.
    if (getBatteryVoltage() > 3.4)
    {
        dataLogger.turnOnSDcard(true);  // true = wait for card to settle after power up
        dataLogger.createLogFile(true);  // true = write a new header
        dataLogger.turnOffSDcard(true);  // true = wait for internal housekeeping after write
    }

    // Call the processor sleep
    Serial.println(F("Putting processor to sleep\n"));
    dataLogger.systemSleep();
}


// ==========================================================================
// Main loop function
// ==========================================================================

// Use this short loop for simple data logging and sending
// /*
void loop()
{
    // Note:  Please change these battery voltages to match your battery
    // At very low battery, just go back to sleep
    if (getBatteryVoltage() < 3.4)
    {
        dataLogger.systemSleep();
    }
    // At moderate voltage, log data but don't send it over the modem
    else if (getBatteryVoltage() < 3.55)
    {
        dataLogger.logData();
    }
    // If the battery is good, send the data to the world
    else
    {
        dataLogger.logDataAndPublish();
    }
}
